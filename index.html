<!-- When we start to design the website, we'll sperate the html and js, but this is easier to do for the time being-->




<html>
<header></header>

<body>
    <main>
        <canvas id="ctx" width="500" height="500" style="border: 1px solid #000000;"></canvas> 
    </main>
</body>

<script src="/socket.io/socket.io.js"></script> <!-- Need to import the IO script-->>
<script>
    var ctx = document.getElementById("ctx").getContext("2d"); //Cavas object with 2d context to draw. 
    ctx.font = "30px Arial";
    var socket = io();  //socket object
    socket.on('newPositions', (playerData) => {  //Listening for the newPosition message from server. This function takes in the player array, and will draw them to the cavas. 
        ctx.clearRect(0, 0, 500, 500);
        for (let player of playerData) {
            ctx.fillText(player.name, player.x, player.y);
        }
    });

     // this is where is get's sorta complicated.  document.onkeydown get's called everytime a client presses a key on the the keyboard. 
     // To find what key was pressed, you need to compare it the keycode, so if keyEvent.keyCode === 68, then d was pressed. This is what 
     // the switch statement is doing. It'll sendback a message to the server of "userMovement", which the server will handle, along with an object
     // the object contains the key (char) which was pressed, and a keystate, which is basically used to send back boolean values to update the pressing states of the player. 


    document.onkeydown = (keyEvent) => {
        switch (keyEvent.keyCode) {
            case 68:
                socket.emit('userMovement', {
                    key: 'd',
                    keyState: true
                });
                break;
            case 83:
                socket.emit('userMovement', {
                    key: 's',
                    keyState: true
                });
                break;
            case 65:
                socket.emit('userMovement', {
                    key: 'a',
                    keyState: true
                });
                break;
            case 87:
                socket.emit('userMovement', {
                    key: 'w',
                    keyState: true
                });
                break;
        }

    }

    //This get's called every time a user releases a key from the keyboard, so no longer pressing. So we do the same thing as the previous switch, but we send back false for everything
    // for the keystate.  
    document.onkeyup = (keyEvent) => {
        switch (keyEvent.keyCode) {
            case 68:
                socket.emit('userMovement', {
                    key: 'd',
                    keyState: false
                });
                break;
            case 83:
                socket.emit('userMovement', {
                    key: 's',
                    keyState: false
                });
                break;
            case 65:
                socket.emit('userMovement', {
                    key: 'a',
                    keyState: false
                });
                break;
            case 87:
                socket.emit('userMovement', {
                    key: 'w',
                    keyState: false
                });
                break;
        }

    }
</script>

</html>